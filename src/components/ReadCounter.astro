---
/** 最稳健的阅读数组件：首次阅读 POST 自增，其后只 GET。
 *  用法：<ReadCounter path={Astro.url.pathname} />
 */
const path = Astro.props.path ?? Astro.url.pathname ?? '/';
---
<span class="read-count" data-path={path}>—</span>
<script is:inline>
  (() => {
    // 关键：is:inline 确保脚本不会被 hoist 到 <head>；就地拿到兄弟元素
    const s = document.currentScript;
    if (!(s instanceof HTMLScriptElement)) return;
    const el = s.previousElementSibling;
    if (!(el instanceof HTMLElement)) return;

    const path = el.getAttribute('data-path') || location.pathname;
    const key = 'fuwari:read:' + path;
    const first = !localStorage.getItem(key);

    // 注意：如果你的站是“纯静态托管”（GitHub Pages 等），把 API 改成完整函数地址
    const API = 'https://blog-count-api.vercel.app/api/counter';
    const url = first ? API : `${API}?type=post&path=${encodeURIComponent(path)}`;
    const opt = first
      ? { method: 'POST', headers: { 'content-type': 'application/json' },
          body: JSON.stringify({ type: 'post', path }) }
      : {};

    if (first) localStorage.setItem(key, '1');

    fetch(url, opt)
      .then(r => { if (!r.ok) throw new Error('HTTP ' + r.status); return r.json(); })
      .then(d => {
        const n = Number(d?.count ?? d ?? 0);
        el.textContent = new Intl.NumberFormat().format(Number.isFinite(n) ? n : 0);
      })
      .catch(err => {
        console.error('[ReadCounter]', err);
        el.textContent = 'N/A';
      });
  })();
</script>
