---
/** 最稳健的阅读数组件：首次阅读 POST 自增，其后只 GET。
 *  用法：<ReadCounter path={Astro.url.pathname} />
 */
const path = Astro.props.path ?? Astro.url.pathname ?? '/';
---
<span class="read-count" data-path={path}>—</span>
<script is:inline>
  (() => {
    const s = document.currentScript;
    if (!(s instanceof HTMLScriptElement)) return;
    const el = s.previousElementSibling;
    if (!(el instanceof HTMLElement)) return;

    const path = el.getAttribute('data-path') || location.pathname;
    const API = 'https://blog-count-api.vercel.app/api/counter';

    // 同一标签页生命周期内防抖：避免同一路径在本次打开期间被重复计数
    // 刷新会清空这段内存，因此刷新会再次 +1
    const guard = (window.__readCounterPosted ||= new Set());
    const alreadyPosted = guard.has(path);

    const url = alreadyPosted ? `${API}?type=post&path=${encodeURIComponent(path)}` : API;
    const opt = alreadyPosted
      ? { method: 'POST', headers: { 'content-type': 'application/json' },
          body: JSON.stringify({ type: 'post', path }) }
      : { method: 'POST', headers: { 'content-type': 'application/json' },
          body: JSON.stringify({ type: 'post', path }) };

    // 第一次进入本页（在当前标签页生命周期里）做一次标记
    if (!alreadyPosted) guard.add(path);

    fetch(url, opt)
      .then(r => { if (!r.ok) throw new Error('HTTP ' + r.status); return r.json(); })
      .then(d => {
        const n = Number(d?.count ?? d ?? 0);
        el.textContent = new Intl.NumberFormat().format(Number.isFinite(n) ? n : 0);
      })
      .catch(err => {
        console.error('[ReadCounter]', err);
        el.textContent = 'N/A';
      });
  })();
</script>